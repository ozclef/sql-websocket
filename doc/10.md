





























Perfecto — con tu **URL** y **anon key** ya podemos dejar esto funcionando ahora mismo. Respira: te doy todo lo mínimo necesario (SQL + JS + HTML corto) para que **login por device + chat en tiempo real** funcionen en Vercel usando **Supabase Realtime**. Lo pongo directo y sin vueltas: copia, pega y ejecuta.

---

## 1) SQL (ejecuta en SQL Editor de Supabase)

Crea la tabla `messages` y habilita RLS para tablas sensibles (`profiles`, `admin_whitelist`) de forma segura para demo. Ve al **SQL Editor** y corre esto:

```sql
-- 1) Tabla de mensajes
create table if not exists public.messages (
  id bigint generated always as identity primary key,
  device_id text not null,
  sender text not null,
  receiver text not null,
  content text not null,
  created_at timestamptz default now()
);

-- 2) Habilitar RLS en messages y permitir anon/auth (demo)
alter table public.messages enable row level security;
create policy "allow_all_messages" on public.messages
  for all
  to anon, authenticated
  using (true)
  with check (true);

-- 3) Recomendado: habilitar RLS en tablas importantes (profiles/admin_whitelist)
-- Esto evita el warning que ves en el dashboard.
alter table if exists public.profiles enable row level security;
alter table if exists public.admin_whitelist enable row level security;

-- Policies simples de ejemplo para profiles (ajusta luego):
-- Permitir que un usuario autenticado lea/escriba solo su perfil (si usas auth)
-- Si no usas auth, déjalas deshabilitadas hasta que definas reglas.
create policy if not exists "profiles_self" on public.profiles
  for all
  to authenticated
  using (auth.uid() = id)
  with check (auth.uid() = id);
```

> Ejecuta todo. Si tu `profiles` o `admin_whitelist` no existen, los `ALTER`/`CREATE POLICY` no harán daño (si no existe la tabla, supabase mostrará error solo en ese bloque; en realidad puedes ejecutar solo la parte `messages` si quieres).

---

## 2) Client: inicializar Supabase (usa tus credenciales)

Tú me diste:

* URL: `https://hxizcwxoluyayrsxsbnn.supabase.co`
* anon key: `eyJhbGci...3P6g`

Eso es la **anon public key** (la correcta para uso en front). Pega exactamente esto en tu front.

### a) Código JS principal (chat + device-id + realtime)

Crea un archivo `chat.js` y pega:

```html
<!-- necesitas el cliente oficial; lo incluyo por CDN -->
<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

const SUPABASE_URL = 'https://hxizcwxoluyayrsxsbnn.supabase.co'
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh4aXpjd3hvbHV5YXlyc3hzYm5uIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE4ODkwMTUsImV4cCI6MjA3NzQ2NTAxNX0.yGJvUG6YXcdCXXDon9YcBESj8-Z7XPF0NLDDfTN3P6g'

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

/* Device id (persistente por browser/device) */
function getOrCreateDeviceId(){
  let id = localStorage.getItem('mf_deviceId')
  if(id) return id
  id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('d_' + Math.random().toString(36).slice(2,10))
  localStorage.setItem('mf_deviceId', id)
  return id
}
const DEVICE_ID = getOrCreateDeviceId()
/* Rol simple: 'cliente' o 'vendedor' (puedes cambiar en UI) */
let ROLE = localStorage.getItem('mf_role') || 'cliente'
function setRole(r){ ROLE = r; localStorage.setItem('mf_role', r); renderRoleUI() }

/* UI helpers: asume elementos en DOM */
const box = document.getElementById('msgBox')
const input = document.getElementById('msgInput')
const sendBtn = document.getElementById('sendBtn')
const roleToggle = document.getElementById('roleToggle')
const clearBtn = document.getElementById('clearBtn')

function appendMessage(m){
  const d = document.createElement('div')
  d.className = 'msg-row'
  const time = new Date(m.created_at).toLocaleTimeString()
  const who = (m.device_id === DEVICE_ID) ? 'Yo' : m.sender + ' • ' + m.device_id.slice(0,6)
  d.textContent = `${time} — ${who}: ${m.content}`
  box.appendChild(d)
  box.scrollTop = box.scrollHeight
}

/* Escuchar mensajes en tiempo real (filtrado en cliente) */
async function subscribeRealtime(){
  // Suscribimos a inserts en public.messages
  await supabase.channel('public:messages')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {
      const m = payload.new
      // Mostrar solo mensajes dirigidos a mi rol/dispositivo o propios
      // Puedes ajustar la lógica: aquí mostramos todo para demo
      appendMessage(m)
    })
    .subscribe()
}

/* Cargar últimos mensajes (opcional) */
async function loadRecent(){
  const { data, error } = await supabase
    .from('messages')
    .select('*')
    .order('created_at', { ascending: true })
    .limit(200)
  if(error) { console.error(error); return }
  box.innerHTML = ''
  data.forEach(appendMessage)
}

/* Enviar mensaje */
async function sendMessage(){
  const content = input.value.trim()
  if(!content) return
  const payload = {
    device_id: DEVICE_ID,
    sender: ROLE,
    receiver: ROLE === 'cliente' ? 'vendedor' : 'cliente',
    content
  }
  const { error } = await supabase.from('messages').insert([payload])
  if(error){ console.error('Error insert message', error); alert('Error al enviar') }
  else { input.value = '' }
}

/* Botones */
sendBtn.onclick = sendMessage
roleToggle.onclick = () => { setRole(ROLE === 'cliente' ? 'vendedor' : 'cliente') }
clearBtn.onclick = async () => {
  if(!confirm('Borrar mensajes locales? (no borra la DB en Supabase)')) return
  // sólo limpia UI local
  box.innerHTML = ''
}

/* UI inicial */
function renderRoleUI(){
  const el = document.getElementById('roleLabel')
  if(el) el.textContent = 'Rol: ' + ROLE
}

/* Iniciar */
(async function init(){
  renderRoleUI()
  await loadRecent()
  await subscribeRealtime()
  console.log('Iniciado con deviceId:', DEVICE_ID, 'role:', ROLE)
})()

// expose small helpers for console
window.SUPABASE = { supabase, DEVICE_ID, setRole }
</script>
```

> Nota: ese script usa `@supabase/supabase-js` moderno vía CDN (ESM). Si tu HTML no permite `<script type="module">`, dímelo y adapto a otro formato.

---

## 3) HTML mínimo para integrar (usa tu CSS anterior)

Añade esto donde quieras en tu `index.html` (manteniendo tu CSS):

```html
<div style="padding:12px">
  <div id="roleLabel" class="small"></div>
  <button id="roleToggle" class="btn secondary">Cambiar rol cliente/vendedor</button>
</div>

<div id="msgBox" style="height:320px; overflow:auto; border:1px solid rgba(0,0,0,0.08); padding:8px; margin:12px 0;"></div>

<div style="display:flex; gap:8px; align-items:center">
  <input id="msgInput" class="input" placeholder="Escribe tu mensaje..." style="flex:1" />
  <button id="sendBtn" class="btn">Enviar</button>
  <button id="clearBtn" class="btn secondary">Limpiar UI</button>
</div>

<!-- luego carga chat.js (el <script type="module"> anterior) -->
```

Si ya tienes `aside-right` en tu layout, mueve los elementos ahí.

---

## 4) Probar paso a paso (checklist rápido)

1. Ejecutaste el SQL en el **SQL Editor** (tabla `messages` + policy).
2. Subiste tu `index.html` + `chat.js` a Vercel o abriste localmente (si usas modules, sirvelo sobre http(s) o Vercel).
3. Abres **dos pestañas** en tu sitio: en una dejas rol `cliente`, en otra `vendedor` (usa el botón Cambiar rol).
4. Escribes y presionas **Enviar** → el mensaje aparecerá en ambas pestañas en tiempo real.
5. Si no ves mensajes: abre **Consola (F12)** y busca errores (network / console). Copia el error y me lo pegas.

---

## 5) Troubleshooting rápido (si algo falla)

* Si `subscribe` no funciona → revisa en **Settings → Realtime** que Realtime esté habilitado y que tu DB tenga wal2json extension (Supabase lo trae por defecto).
* Si `INSERT` falla con `permission denied` → revisa que la policy `allow_all_messages` exista (o pon temporalmente `.using(true) to anon, authenticated`).
* Si `createClient` lanza `invalid key` → revisa que no hayas copiado la **service_role key** en vez de la **anon key** (la tuya parece anon, está bien).
* Si recibes errores de CORS/Network → abre Network y pega aquí el texto del error.

---

## 6) Seguridad / notas finales (sí, importante)

* La `anon key` es segura para usar **en frontend** (es la intención), pero no la uses para operaciones administrativas.
* RLS debería ajustarse después del demo para que solo usuarios autenticados vean los mensajes que les corresponden. Para la demo es OK dejar `allow_all` si quieres rapidez.
* Si en el panel ves warnings sobre `public.*` sin RLS, sigue los pasos del SQL para habilitar RLS (ya incluido arriba).

---

Si quieres, hago esto por ti ahora mismo:

* Te dejo un `index.html` completo (con tu CSS original, layout y chat integrado) listo para copiar/pegar en Vercel.
* O te dejo solo el `chat.js` adaptado a tu HTML existente.

Dime **qué prefieres** y te lo pego entero en la siguiente respuesta — ya con tu `SUPABASE_URL` y `anon key` incrustados para que pegues en tu repo y lo despliegues. No te muerdo; lo hacemos ya.
